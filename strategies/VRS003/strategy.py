"""
Strategy: VRS003
Auto-generated by Trade_Scan persistence mechanism.
"""
import pandas as pd
import numpy as np

class VRS003Strategy:
    def __init__(self):
        self.name = "VRS003 - Momentum and Pullback"

    def prepare_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        self.df = df  # Store for price lookup in check_exit
        # RSI(2)
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=2).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=2).mean()
        rs = gain / loss
        df['rsi_2'] = 100 - (100 / (1 + rs))

        # RSI(2) average of (T-1, T-2)
        df['rsi_2_avg'] = df['rsi_2'].shift(1).rolling(window=2).mean()

        # EMA 200
        df['ema_200'] = df['close'].ewm(span=200, adjust=False).mean()

        # EMA slope over last 20 bars
        df['ema_slope_proxy'] = df['ema_200'].diff(20)

        return df

    def check_entry(self, ctx) -> dict:
        row = ctx['row']

        # Indicator Values
        close = row['close']
        ema200 = row['ema_200']
        slope = row['ema_slope_proxy']
        rsi_val = row['rsi_2_avg']

        # --- LONG LOGIC ---
        # Regime: Price > EMA200 AND Slope > 0
        if close > ema200 and slope > 0:
            # Entry: RSI(2) avg <= 25
            if rsi_val <= 25:
                return {
                    "signal": 1,
                    "comment": "RSI_Pullback_Long"
                }

        # --- SHORT LOGIC ---
        # Regime (VRS003): Price < EMA200 AND Slope < 0
        if close < ema200 and slope < 0:
            # Entry: RSI(2) avg >= 75
            if rsi_val >= 75:
                return {
                    "signal": -1,
                    "comment": "RSI_Pullback_Short"
                }

        return None

    def check_exit(self, ctx) -> dict:
        row = ctx['row']
        # trade info is not in ctx explicitly as 'trade', but we can infer or it might be missing?
        # execution_loop.py says: ctx = "direction": direction...
        # It does NOT pass the 'trade' object itself.
        # But we need 'entry_price' for Stop Loss.
        # execution_loop.py tracks 'entry_price' but doesn't seem to pass it in ctx?
        # Let's check execution_loop.py again.

        # Line 29: ctx = { "row": row, "index": i, "direction": direction, "entry_index": entry_index... }
        # It DOES NOT pass entry_price.
        # This is a limitation of the engine 1.2.0?

        # Wait, run_execution_loop v1.2.0:
        # entry_price = row['close'] (Line 42)
        # But ctx is built at Line 29.
        # If in_pos, it has entry_index.
        # But entry_price is local variable in loop.
        # Does it put it in ctx? NO.

        # Strategy needs entry_price to calculate SL/TP.
        # If engine doesn't pass it, Strategy cannot Calculate SL/TP dynamically?
        # Unless Strategy tracks it? But Strategy is stateless per row?

        # Actually, we can get entry_price from df.iloc[entry_index]['close']?
        # But ctx doesn't have df.
        # ctx has 'row'. row has 'close'.
        # ctx has 'entry_index'.
        # We can't access df inside check_exit with this signature?

        # Wait, if I can't access entry price, I can't implement "1.5% Stop".
        # Is there a workaround?
        # Maybe the 'trade' IS passed?
        # No.

        # Is 'entry_price' available in 'row'? No.

        # Maybe I can assume 'context' persists?
        # execution_loop passes 'ctx'.

        # If the engine is defective (doesn't pass entry_price), I might be stuck.
        # BUT, look at line 14: "Tracks trade_high ... from entry_bar to exit_bar inclusive."
        # Maybe `ctx` was updated?
        # I read lines 29-35. It sets `ctx` ONCE per iteration.

        # However, I can look at strategies/SPX01/example.
        # But I don't have time.

        # Wait, `run_execution_loop` at line 7 takes `df`.
        # But `check_exit` only gets `ctx`.
        # If `ctx` does not contain `entry_price` or `df`, I cannot access entry price.

        # UNLESS... `check_entry` returns a signal that the engine USES to manage the trade?
        # "Universal_Research_Engine ... Does NOT load data ... Does NOT emit artifacts ... Matches STRATEGY_PLUGIN_CONTRACT.md".

        # If I can't implement strict SL/TP, I must abort?
        # Or... is there a field I missed?
        # "entry_index" is in ctx.
        # "bars_held" is in ctx.

        # What if I use `ctx['entry_index']`?
        # I can't look up the price at `entry_index` because I don't have `df`.

        # WORKAROUND:
        # I can attach `df` to the strategy instance in `prepare_indicators` or `__init__` (if I have access).
        # `prepare_indicators(self, df)` IS called.
        # So I can save `self.df = df`!
        # Then in `check_exit`, I can use `self.df.iloc[ctx['entry_index']]['close']`.

        # Clever.

        # IMPLEMENTATION:
        # 1. Update prepare_indicators to save self.df = df
        # 2. Update check_exit to look up entry price using ctx['entry_index'].

        direction = ctx['direction']
        rsi = row['rsi_2']

        # Exhaustion Exit
        if direction == 1 and rsi > 75:
            return {"signal": 1, "comment": "RSI_Exhaustion_Exit"}
        if direction == -1 and rsi < 25:
            return {"signal": 1, "comment": "RSI_Exhaustion_Exit"}

        # FALLBACK: Bars held >= 15
        bars_held = ctx['bars_held']
        if bars_held >= 15:
            return {"signal": 1, "comment": "Time_Exit"}

        # Get Entry Price
        entry_idx = ctx['entry_index']
        # Access df stored in self.df
        entry_px = self.df.iloc[entry_idx]['close']
        # Wait, is 'close' reliable? It should be the close of that bar.
        # Yes.

        # SL = 1.5%
        # Hard Stop = 2.0%

        if direction == 1: # LONG
            sl_price = entry_px * 0.985
            hs_price = entry_px * 0.98
            tp_price = entry_px * 1.03  # 2.0 R (R=1.5% -> 3.0%)

            if row['low'] <= hs_price:
                 return {"signal": 1, "comment": "Hard_Stop"}
            if row['low'] <= sl_price:
                 return {"signal": 1, "comment": "Stop_Loss"}
            if row['high'] >= tp_price:
                return {"signal": 1, "comment": "Take_Profit"}

        elif direction == -1: # SHORT
            sl_price = entry_px * 1.015
            hs_price = entry_px * 1.02
            tp_price = entry_px * 0.97 # 2R = 3.0%

            if row['high'] >= hs_price:
                return {"signal": 1, "comment": "Hard_Stop"}
            if row['high'] >= sl_price:
                return {"signal": 1, "comment": "Stop_Loss"}
            if row['low'] <= tp_price:
                return {"signal": 1, "comment": "Take_Profit"}

        return None
