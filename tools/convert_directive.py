"""
tools/convert_directive.py -- Flat-Text -> YAML Scaffold Utility

Phase 3 Fix 5: Provides a conversion path for legacy flat-text directives.

Usage:
    python tools/convert_directive.py <path_to_flat_text_directive>

Output:
    /tmp/<DIRECTIVE_ID>_scaffold.yaml

What this does:
    - Reads a flat-text directive (any format)
    - Emits a YAML scaffold with canonical block structure
    - Does NOT infer, guess, or fill any values
    - User fills all parameters manually before running the pipeline

What this does NOT do:
    - Auto-fill parameters from the flat text
    - Validate the flat text
    - Write to backtest_directives/ (that is a human step)
    - Run canonicalization (that is a separate step)
"""

import sys
from pathlib import Path

# Canonical block scaffold — matches canonical_schema.py CANONICAL_BLOCKS order
SCAFFOLD = """\
# Generated by tools/convert_directive.py
# Fill all values. Do NOT leave empty strings in production directives.
# Run tools/canonicalizer.py after filling to validate structure.

test:
  name: ""             # Strategy ID (e.g. IDX22)
  family: ""           # Strategy family (e.g. Index)
  strategy: ""         # Must match strategies/<X>/strategy.py directory name

  broker: ""           # e.g. OctaFx
  timeframe: ""        # e.g. 1d, 4h, 15m
  session_time_reference: UTC

  start_date: ""       # e.g. 2015-01-01
  end_date: ""         # e.g. 2026-01-31

  research_mode: false
  tuning_allowed: false
  parameter_mutation: false

  description: >
    (describe the strategy here)

symbols:
  - ""                 # Add one symbol per line, e.g. SPX500

indicators:
  - ""                 # Add indicator module paths, e.g. indicators.volatility.atr

execution_rules:
  pyramiding: false
  entry_when_flat_only: true
  reset_on_exit: true

  entry_logic:
    type: ""           # e.g. volatility_pullback
    lookback_bars:
    atr_length:
    condition: ""      # e.g. close_less_than_hh_minus_atr

  exit_logic:
    type: ""           # e.g. dynamic_or_time
    price_exit: ""     # e.g. close_greater_than_hh_prev
    time_exit_bars:

  stop_loss:
    type: none

  trailing_stop:
    enabled: false

order_placement:
  type: market
  execution_timing: next_bar_open

trade_management:
  direction: ""        # e.g. long_only, short_only, both
  reentry:
    allowed: false
"""


def main():
    if len(sys.argv) < 2:
        print("Usage: python tools/convert_directive.py <path_to_flat_text_directive>")
        print("Output: /tmp/<ID>_scaffold.yaml")
        sys.exit(1)

    input_path = Path(sys.argv[1])
    if not input_path.exists():
        print(f"[ERROR] File not found: {input_path}")
        sys.exit(1)

    directive_id = input_path.stem
    output_path = Path("/tmp") / f"{directive_id}_scaffold.yaml"

    # Write scaffold — no parsing, no inference
    output_path.write_text(SCAFFOLD, encoding="utf-8")

    print("=" * 60)
    print("DIRECTIVE SCAFFOLD GENERATOR -- Phase 3 Fix 5")
    print("=" * 60)
    print(f"  Input (ignored semantically): {input_path}")
    print(f"  Output scaffold:              {output_path}")
    print()
    print("[INFO] The scaffold contains the canonical YAML block structure.")
    print("[INFO] Fill all values manually. No values were inferred.")
    print("[INFO] After filling, run:")
    print(f"         python tools/canonicalizer.py {output_path}")
    print("       to validate the structure before placing in backtest_directives/active/")
    print()
    print("[DONE] Scaffold written.")


if __name__ == "__main__":
    main()
