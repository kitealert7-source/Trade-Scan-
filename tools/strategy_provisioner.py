"""
strategy_provisioner.py — Preflight Strategy Artifact Provisioner

Authority: SOP_TESTING (Stage-0 Provisioning)
Purpose:
    - Deterministically provision valid strategy artifacts from Directive.
    - Ensure Stage-0.5 Semantic Validation passes.
    - Idempotent: Can run multiple times without destructive side effects unless determining drift.

Rules:
    1. READ-ONLY on Directive.
    2. CREATE/UPDATE on strategies/<StrategyName>/.
    3. THIN TEMPLATE: Generates structural boilerplate only.
    4. NO INFERENCE: Imports strictly from directive['indicators'].
    5. SIGNATURE-ONLY UPDATE: If file exists, only update signature block and ensure imports.
    6. STRICT MARKERS: Validate marker presence and order before touching file.
    7. DETERMINISTIC IMPORTS: Inject missing imports only, no reordering.
"""

import sys
import shutil
from pathlib import Path
import json
import re

# Project Setup
PROJECT_ROOT = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

# Template for strategy.py
STRATEGY_TEMPLATE = """\"\"\"
{strategy_name} — Generated by Strategy Provisioner
Timestamp: {timestamp}
Directive: {strategy_name}
\"\"\"

# --- IMPORTS (Deterministic from Directive) ---
{imports_block}

class Strategy:
    
    # --- IDENTITY ---
    name = "{strategy_name}"
    timeframe = "{timeframe}"
    
    # --- STRATEGY SIGNATURE START ---
    STRATEGY_SIGNATURE = {signature_json}
    # --- STRATEGY SIGNATURE END ---
    
    def __init__(self):
        self.filter_stack = FilterStack(self.STRATEGY_SIGNATURE)

    
    def prepare_indicators(self, df):
        \"\"\"
        Compute indicators here.
        Must return the dataframe with new columns.
        \"\"\"
        return df

    def check_entry(self, ctx):
        \"\"\"
        Return entry signal dict or None.
        e.g. {{"signal": 1}} for Long
        \"\"\"
        return None

    def check_exit(self, ctx):
        \"\"\"
        Return True to close position.
        \"\"\"
        return False
"""

def _generate_import_lines(indicators):
    lines = []
    for ind in indicators:
        if not ind: continue
        # Clean path to module notation
        mod_path = ind.replace("\\", "/").replace("/", ".").replace(".py", "")
        
        if not mod_path.startswith("indicators."):
            mod_path = f"indicators.{mod_path}"
        
        symbol = mod_path.split(".")[-1]
        lines.append(f"from {mod_path} import {symbol}")
    return lines

def _insert_imports(content: str, required_imports: list) -> str:
    """
    Inject missing imports into content.
    - Scans for existing 'from ... import ...' lines.
    - Inserts new imports after the last existing import.
    - OR after docstring if no imports.
    - OR at top if nothing found.
    - Does NOT reorder or duplicate.
    """
    lines = content.splitlines()
    existing_imports = set()
    last_import_idx = -1
    
    # 1. Scan for existing imports
    import_regex = re.compile(r"^from\s+[\w\.]+\s+import\s+\w+")
    
    for i, line in enumerate(lines):
        if import_regex.match(line.strip()):
            existing_imports.add(line.strip())
            last_import_idx = i

    imports_to_add = []
    for imp in required_imports:
        if imp not in existing_imports:
            imports_to_add.append(imp)
            
    if not imports_to_add:
        return content # No changes needed

    # 2. Determine Insertion Point
    insert_idx = 0
    
    if last_import_idx != -1:
        # Insert after last import
        insert_idx = last_import_idx + 1
    else:
        # No imports found. Look for docstring end.
        docstring_end_regex = re.compile(r'\"\"\"|\'\'\'')
        docstring_matches = list(docstring_end_regex.finditer(content))
        
        if len(docstring_matches) >= 2:
            # Assumes module docstring is the first block
            # We want to insert after the second match (end of docstring)
            # But converting char index to line index is tricky with just regex
            # Let's iterate lines to find docstring boundaries?
            # Simple heuristic: If line starts with triple quote and we found 2 calls,
            # assume module docstring is done.
            # Safe Fallback: Top of file (after docstring usually works by lines)
            
            # Let's find line index of second triple quote?
            count = 0
            for i, line in enumerate(lines):
                if '"""' in line or "'''" in line:
                    count += line.count('"""') + line.count("'''")
                    if count >= 2:
                        insert_idx = i + 1
                        break
    
    # 3. Inject
    # Add a newline for separation if inserting into code body
    prefix = []
    if last_import_idx == -1 and insert_idx > 0:
        prefix = [""] 
        
    lines[insert_idx:insert_idx] = prefix + imports_to_add
    
    return "\n".join(lines)

def _update_existing_strategy(file_path: Path, signature: dict, required_imports: list) -> bool:
    """
    Update existing strategy file:
    1. Validate Markers.
    2. Replace STRATEGY_SIGNATURE block.
    3. Inject missing imports via _insert_imports.
    4. Idempotency Check.
    """
    try:
        content = file_path.read_text(encoding="utf-8")
        original_content = content
        
        # 1. Validate Markers
        start_marker = "# --- STRATEGY SIGNATURE START ---"
        end_marker = "# --- STRATEGY SIGNATURE END ---"
        
        if content.count(start_marker) != 1:
            raise ValueError(f"File must contain exactly one START marker. Found {content.count(start_marker)}")
        if content.count(end_marker) != 1:
            raise ValueError(f"File must contain exactly one END marker. Found {content.count(end_marker)}")
            
        start_idx = content.find(start_marker)
        end_idx = content.find(end_marker)
        
        if start_idx >= end_idx:
             raise ValueError("Malformed markers: START appears after END.")

        # 2. Update Signature Block
        sig_json = json.dumps(signature, indent=4, sort_keys=True)
        
        # Convert JSON literals to Python literals for valid code generation
        # NOTE: This replaces values only (preceded by ": ") to avoid touching keys
        sig_json = sig_json.replace(": true", ": True").replace(": false", ": False").replace(": null", ": None")

        new_block = f"{start_marker}\n    STRATEGY_SIGNATURE = {sig_json}\n    {end_marker}"
        
        # Precise Regex Replace
        pattern = re.compile(f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL)
        content = pattern.sub(new_block, content, count=1)
        
        # 3. Inject Imports
        content = _insert_imports(content, required_imports)

        # 4. Idempotency Check
        if content != original_content:
            file_path.write_text(content, encoding="utf-8")
            print(f"[PROVISION] Updated strategy signature: {file_path}")
        else:
            print(f"[PROVISION] Strategy signature already up to date: {file_path}")
            
        return True

    except Exception as e:
        print(f"[PROVISION] Update Failed: {e}")
        return False

# ... (removed import yaml below)

from tools.directive_utils import load_directive_yaml, get_key_ci

SIGNATURE_SCHEMA_VERSION = 1

def provision_strategy(directive_path: str) -> bool:
    """
    Provision strategy artifacts from directive.
    Returns True if successful/exists, False on failure.
    """
    try:
        d_path = Path(directive_path)
        if not d_path.exists():
            print(f"[PROVISION] Directive not found: {d_path}")
            return False

        # 1. Parse Directive (Direct YAML Load via Shared Utility)
        d_conf = load_directive_yaml(d_path)
        
        # 2. Extract Identity & Signature Elements
        # Handle snake_case vs TitleCase key variations if necessary.
        # Direct YAML keys are usually case-sensitive from the file.
        # We look for standard keys.
        
        # Identity - Check "test" block first, then root
        test_block = get_key_ci(d_conf, "test") or {}
        
        s_name = get_key_ci(test_block, "strategy") or get_key_ci(d_conf, "strategy")
        timeframe = get_key_ci(test_block, "timeframe") or get_key_ci(d_conf, "timeframe")
        
        if not s_name:
            print("[PROVISION] Directive missing 'Strategy' field (checked root and 'test' block).")
            return False
        
        # 3. Target Directory
        strategy_dir = PROJECT_ROOT / "strategies" / s_name
        strategy_file = strategy_dir / "strategy.py"
        
        # 4. Construct Signature Elements (Direct Extraction)
        # Check root first for specific sections, then test block?
        # Usually sections like range_definition are at root.
        
        indicators = get_key_ci(d_conf, "indicators") or get_key_ci(test_block, "indicators") or []
        if isinstance(indicators, str): indicators = [indicators]
        
        vol_filter = get_key_ci(d_conf, "volatility_filter") or get_key_ci(test_block, "volatility_filter") or {}
        range_def = get_key_ci(d_conf, "range_definition") or get_key_ci(test_block, "range_definition") or {}
        trade_mgmt = get_key_ci(d_conf, "trade_management") or get_key_ci(test_block, "trade_management") or {}
        exec_rules = get_key_ci(d_conf, "execution_rules") or get_key_ci(test_block, "execution_rules") or {}
        
        # The line below is already present, no change needed based on the instruction's intent
        # SIGNATURE_SCHEMA_VERSION = 1 
        
        order_placement = get_key_ci(d_conf, "order_placement") or get_key_ci(test_block, "order_placement") or {}
        
        signature = {
            "signature_version": SIGNATURE_SCHEMA_VERSION,
            "indicators": indicators,
            "volatility_filter": vol_filter,
            "range_definition": range_def,
            "trade_management": trade_mgmt,
            "execution_rules": exec_rules,
            "order_placement": order_placement  # Add this just in case
        }
        
        # 5. Build Import Requirements
        import_lines = _generate_import_lines(indicators)
        import_lines.append("from engines.filter_stack import FilterStack")
        
        # 6. Check Existence
        if strategy_file.exists():
            return _update_existing_strategy(strategy_file, signature, import_lines)
        else:
            print(f"[PROVISION] Creating new strategy: {s_name}")
            strategy_dir.mkdir(parents=True, exist_ok=True)

            # 7. Generate Content
            from datetime import datetime
            
            sig_json = json.dumps(signature, indent=4, sort_keys=True)
            sig_json = sig_json.replace(": true", ": True").replace(": false", ": False").replace(": null", ": None")
            
            content = STRATEGY_TEMPLATE.format(
                strategy_name=s_name,
                timestamp=datetime.now().isoformat(),
                imports_block="\n".join(import_lines),
                timeframe=timeframe,
                signature_json=sig_json
            )
            
            # 8. Write File
            with open(strategy_file, "w", encoding="utf-8") as f:
                f.write(content)
                
            print(f"[PROVISION] SUCCESS: {strategy_file}")
            return True

    except Exception as e:
        print(f"[PROVISION] FAILED: {e}")
        return False

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python tools/strategy_provisioner.py <DIRECTIVE_PATH>")
        sys.exit(1)
    
    provision_strategy(sys.argv[1])
